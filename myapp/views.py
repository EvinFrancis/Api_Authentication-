from urllib import request
from django.shortcuts import render
from rest_framework.views import APIView
from myapp.models import User
from myapp.serializers import User_Serializer
from rest_framework.response import Response
from rest_framework import status

#obj contains:
# obj.initial_data → request data (dict)

# obj.fields → serializer field objects

# obj._errors → empty (initially)

# obj._validated_data → not created yet
# Create your views here.
class Registrations(APIView):
    def post(self,request):
        
        #this is////////////  ....... DESERIALIZATION...///////
        obj=User_Serializer(data=request.data)
        print(request.data)
        obj.is_valid(raise_exception=True)
        print(obj)      
        obj.save()
        return Response({"New user:":obj.data},status=status.HTTP_200_OK)
    
#     JSON (request)
#    ↓
# Python dict (request.data)
#    ↓
# Serializer  ←  THIS LINE
#    ↓
# validated_data
#    ↓
# Model object

#///////////////#this line is............ SERIALIZATION./...........//////////////
    
    def get(self, request):
        use=User.objects.all()
        print(use)
        obj=User_Serializer(use, many=True)#this line is SERIALIZATION.
        print(obj)
        return Response(obj.data,status.HTTP_200_OK)
    
#  Database
#    ↓
# User model objects (QuerySet)
#    ↓
# User_Serializer(use, many=True)
#    ↓
# Python list of dicts (obj.data)
#    ↓
# JSON response
    def put(self,request):
        data1=request.data
        try:
         obj=User.objects.get(id=data1["id"])
        except User.DoesNotExist:
            return Response("data not exist....",status=status.HTTP_400_BAD_REQUEST)
    
    
        use=User_Serializer(obj,data=data1)
     
        use.is_valid(raise_exception=True)
        use.save()
        return Response("updated succesfully...",status.HTTP_200_OK)
    

    def patch(self,request):
        data1=request.data
        try:
         obj=User.objects.get(id=data1["id"])
        except User.DoesNotExist:
            return Response("data not exist....",status=status.HTTP_400_BAD_REQUEST)
    
    
        use=User_Serializer(obj,data=data1,partial=True)#PATCH works because of partial=True,
        #....not because of extra_kwargs.
     
        use.is_valid(raise_exception=True)
        use.save()
        return Response("updated partial succesfully...",status.HTTP_200_OK)
    

    def delete(self,request,idd):
       try:
          
            obj=User.objects.get(id=idd)#Never use a variable outside try if it may not be assigned inside try
       except User.DoesNotExist:
          return Response("user db not found" ,status.HTTP_404_NOT_FOUND)
       
       obj.delete()
       
       return Response("Data Deleted sueccessfully...",status=status.HTTP_200_OK)
from rest_framework.exceptions import AuthenticationFailed  
import jwt,datetime
class LoginAPI(APIView):
   def post(self,request):
      uname=request.data.get("email")
      psw=request.data.get("password")
      x=User.objects.filter(email=uname).first()#filter returns a queryset, first() returns the first object or None if no matchif x is not None and x.check_password(psw):#check_password compares the plain password with the hashed password stored in the database
      if x is None:
         raise AuthenticationFailed("Email not found....^^")
      if not x.check_password(psw) :
         raise AuthenticationFailed("Incorrect password....^^")
      payload={
         "id":x.id,
         "exp":datetime.datetime.utcnow()+datetime.timedelta(minutes=30),#token expires in 60 minutes,
         #utc: persent time  + 30 minutes
         "iat":datetime.datetime.utcnow()#issued at time (when token is generated)
         # iat: 2026-06-17 11:30:00 
         #  exp: 2026-06-17 12:00:00 30 minutes

         
      }
      #token is generated by encoding the payload with a secret key and an algorithm (HS256)
      
      token=jwt.encode(payload,"secret",algorithm='HS256')#secret key should be kept safe and not hardcoded in production
      
      
      result=Response()#create an empty response object

      result.set_cookie(key="jwt",value=token,httponly=True)#set the token in a cookie with httponly flag for security

      result.data={
         "your jwt token":token
      }#include the token in the response body as well (optional, since it's already in the cookie)

      return result  #return the response with the token in both cookie and body (for demonstration)
      

class UserAPI(APIView):
   def get (self,request):
      token=request.COOKIES.get("jwt")#get the token from the cookie
      if not token:
         raise AuthenticationFailed("Unauthenticated....^^")
      try:
         payload=jwt.decode(token,"secret",algorithms=['HS256'])#decode the token to get the payload (user id and exp time)
      except jwt.ExpiredSignatureError:
         raise AuthenticationFailed("Token expired....^^")
      except jwt.InvalidTokenError:
         raise AuthenticationFailed("Invalid token....^^")
      
      user=User.objects.filter(id=payload["id"]).first()#get the user from the database using the id from the payload
      if user is None:
         raise AuthenticationFailed("User not found....^^")
      
      serializer=User_Serializer(user)#serialize the user object to return in response
      return Response(serializer.data)
             
    

    
    


